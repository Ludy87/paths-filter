import{createRequire as __WEBPACK_EXTERNAL_createRequire}from"module";if(typeof __nccwpck_require__!=="undefined")__nccwpck_require__.ab=new URL(".",import.meta.url).pathname.slice(import.meta.url.match(/^file:\/\/\/\w:/)?1:0,-1)+"/";var __webpack_exports__={};var __createBinding=undefined&&undefined.__createBinding||(Object.create?function(e,t,i,n){if(n===undefined)n=i;var r=Object.getOwnPropertyDescriptor(t,i);if(!r||("get"in r?!t.__esModule:r.writable||r.configurable)){r={enumerable:true,get:function(){return t[i]}}}Object.defineProperty(e,n,r)}:function(e,t,i,n){if(n===undefined)n=i;e[n]=t[i]});var __setModuleDefault=undefined&&undefined.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:true,value:t})}:function(e,t){e["default"]=t});var __importStar=undefined&&undefined.__importStar||function(){var ownKeys=function(e){ownKeys=Object.getOwnPropertyNames||function(e){var t=[];for(var i in e)if(Object.prototype.hasOwnProperty.call(e,i))t[t.length]=i;return t};return ownKeys(e)};return function(e){if(e&&e.__esModule)return e;var t={};if(e!=null)for(var i=ownKeys(e),n=0;n<i.length;n++)if(i[n]!=="default")__createBinding(t,e,i[n]);__setModuleDefault(t,e);return t}}();Object.defineProperty(exports,"__esModule",{value:true});exports.exportResults=exportResults;exports.run=run;exports.getChangedFilesFromApi=getChangedFilesFromApi;const fs=__importStar(require("fs"));const core=__importStar(require("@actions/core"));const github=__importStar(require("@actions/github"));const filter_1=require("./filter");const file_1=require("./file");const git=__importStar(require("./git"));const shell_escape_1=require("./list-format/shell-escape");const csv_escape_1=require("./list-format/csv-escape");async function run(){try{const e=core.getInput("working-directory",{required:false});if(e){process.chdir(e)}const t=core.getInput("token",{required:false});const i=core.getInput("ref",{required:false});const n=core.getInput("base",{required:false});const r=core.getInput("filters",{required:true});const o=isPathInput(r)?getConfigFileContent(r):r;const s=core.getInput("list-files",{required:false}).toLowerCase()||"none";const a=parseInt(core.getInput("initial-fetch-depth",{required:false}))||10;const u=core.getInput("predicate-quantifier",{required:false})||filter_1.PredicateQuantifier.SOME;if(!isExportFormat(s)){core.setFailed(`Input parameter 'list-files' is set to invalid value '${s}'`);return}if(!(0,filter_1.isPredicateQuantifier)(u)){const e=`Input parameter 'predicate-quantifier' is set to invalid value `+`'${u}'. Valid values: ${filter_1.SUPPORTED_PREDICATE_QUANTIFIERS.join(", ")}`;throw new Error(e)}const c={predicateQuantifier:u};const l=new filter_1.Filter(o,c);const f=await getChangedFiles(t,n,i,a);core.info(`Detected ${f.length} changed files`);const d=l.match(f);exportResults(d,s)}catch(e){core.setFailed(getErrorMessage(e))}}function isPathInput(e){return!(e.includes("\n")||e.includes(":"))}function getConfigFileContent(e){if(!fs.existsSync(e)){throw new Error(`Configuration file '${e}' not found`)}if(!fs.lstatSync(e).isFile()){throw new Error(`'${e}' is not a file.`)}return fs.readFileSync(e,{encoding:"utf8"})}async function getChangedFiles(e,t,i,n){if(t===git.HEAD){if(i){core.notice(`'ref' input parameter is ignored when 'base' is set to HEAD`)}return await git.getChangesOnHead()}const r=["pull_request","pull_request_review","pull_request_review_comment","pull_request_target"];if(r.includes(github.context.eventName)){if(i){core.notice(`'ref' input parameter is ignored when 'base' is set to HEAD`)}if(t){core.notice(`'base' input parameter is ignored when action is triggered by pull request event`)}const n=github.context.payload.pull_request;if(e){return await getChangedFilesFromApi(e,n)}if(github.context.eventName==="pull_request_target"){throw new Error(`'token' input parameter is required if action is triggered by 'pull_request_target' event`)}core.info("Github token is not available - changes will be detected using git diff");const r=github.context.payload.pull_request?.base.sha;const o=github.context.payload.repository?.default_branch;const s=await git.getCurrentRef();const a=typeof r==="string"?r:typeof o==="string"?o:"";return await git.getChanges(t||a,s)}else{return getChangedFilesFromGit(t,i,n)}}async function getChangedFilesFromGit(e,t,i){const n=github.context.payload.repository;const r=n?.default_branch;const o=github.context.eventName==="push"?github.context.payload.before:null;const s=await git.getCurrentRef();t=git.getShortName(t||github.context.ref||s);e=git.getShortName(e||(typeof r==="string"?r:""));if(!t){throw new Error("This action requires 'head' input to be configured, 'ref' to be set in the event payload or branch/tag checked out in current git repository")}if(!e){throw new Error("This action requires 'base' input to be configured or 'repository.default_branch' to be set in the event payload")}const a=git.isGitSha(e);const u=e===t;if(a||u){const n=a?e:o;if(!n){core.warning(`'before' field is missing in event payload - changes will be detected from last commit`);if(t!==s){core.warning(`Ref ${t} is not checked out - results might be incorrect!`)}return await git.getChangesInLastCommit()}if(n===git.NULL_SHA){if(r&&e!==r){core.info(`First push of a branch detected - changes will be detected against the default branch ${r}`);if(typeof r!=="string"){throw new Error("Default branch is not defined or is not a string")}return await git.getChangesSinceMergeBase(r,t,i)}else{core.info("Initial push detected - all files will be listed as added");if(t!==s){core.warning(`Ref ${t} is not checked out - results might be incorrect!`)}return await git.listAllFilesAsAdded()}}core.info(`Changes will be detected between ${n} and ${t}`);return await git.getChanges(n,t)}core.info(`Changes will be detected between ${e} and ${t}`);return await git.getChangesSinceMergeBase(e,t,i)}async function getChangedFilesFromApi(e,t){core.startGroup(`Fetching list of changed files for PR#${t.number} from Github API`);try{const i=github.getOctokit(e);const n=100;const r=[];core.info(`Invoking listFiles(pull_number: ${t.number}, per_page: ${n})`);for await(const e of i.paginate.iterator(i.rest.pulls.listFiles.endpoint.merge({owner:github.context.repo.owner,repo:github.context.repo.repo,pull_number:t.number,per_page:n}))){if(e.status!==200){throw new Error(`Fetching list of changed files from GitHub API failed with error code ${e.status}`)}core.info(`Received ${e.data.length} items`);for(const t of e.data){core.info(`[${t.status}] ${t.filename}`);const e="previous_filename"in t?t.previous_filename:undefined;if(t.status===file_1.ChangeStatus.Renamed){core.info(`Renamed file detected: ${t.filename} (previous: ${e})`);if(e===undefined){core.warning(`Renamed file detected but previous filename is missing: ${t.filename}`);r.push({filename:t.filename,status:file_1.ChangeStatus.Added,from:t.filename})}else{r.push({from:e,to:t.filename,status:file_1.ChangeStatus.Renamed,filename:t.filename})}}else if(t.status===file_1.ChangeStatus.Copied){core.info(`Copied file detected: ${t.filename} (previous: ${e})`);if(e===undefined){core.warning(`Copied file detected but previous filename is missing: ${t.filename}`);r.push({from:t.filename,filename:t.filename,status:file_1.ChangeStatus.Added})}else{r.push({filename:t.filename,to:t.filename,status:file_1.ChangeStatus.Copied,from:e})}}else{const e=t.status==="removed"?file_1.ChangeStatus.Deleted:t.status;r.push({from:t.filename,filename:t.filename,status:e})}}}return r}finally{core.endGroup()}}function exportResults(e,t){core.info("Results:");const i=[];let n=false;const r=Object.keys(e).length;let o=0;for(const[r,s]of Object.entries(e)){const e=s.length>0;if(e){o++}core.startGroup(`Filter ${r} = ${e}`);core.info(`Filter ${r} matched ${s.length} files`);if(s.length>0){i.push(r);n=true;core.info("Matching files:");for(const e of s){const t="previous_filename"in e?e.previous_filename:undefined;if(t===undefined){if(e.status===file_1.ChangeStatus.Renamed||e.status===file_1.ChangeStatus.Copied){core.info(`${e.from} -> ${e.filename} [${e.status}]`)}else{core.info(`${e.filename} [${e.status}]`)}}else{core.info(`[Trigger file: ${t}] - ${e.filename} [${e.status}]`)}}}else{core.info("Matching files: none")}core.setOutput(r,e);core.setOutput(`${r}_count`,s.length);if(t!=="none"){const e=serializeExport(s,t);core.setOutput(`${r}_files`,e)}core.endGroup()}const s=r===o?true:false;core.setOutput("all_changed",s);core.setOutput("any_changed",n);if(e["changes"]===undefined){const e=i.filter((e=>e!=="shared"));const t=JSON.stringify(e);core.info(`Changes output set to ${t}`);core.setOutput("changes",t)}else{core.info("Cannot set changes output variable - name already used by filter output")}}function serializeExport(e,t){const i=e.map((e=>e.filename));switch(t){case"csv":return i.map(csv_escape_1.csvEscape).join(",");case"json":return JSON.stringify(i);case"escape":return i.map(shell_escape_1.backslashEscape).join(" ");case"shell":return i.map(shell_escape_1.shellEscape).join(" ");case"lines":return i.join("\n");default:return""}}function isExportFormat(e){return["none","csv","shell","json","escape","lines"].includes(e)}function getErrorMessage(e){if(e instanceof Error)return e.message;return String(e)}if(__WEBPACK_EXTERNAL_createRequire(import.meta.url).main===__WEBPACK_EXTERNAL_createRequire(import.meta.url).cache[eval("__filename")]){void run()}